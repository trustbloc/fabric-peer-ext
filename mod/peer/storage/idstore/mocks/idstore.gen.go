// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/hyperledger/fabric-protos-go/common"
	"github.com/hyperledger/fabric/core/ledger/kvledger/msgs"
	storageapi "github.com/trustbloc/fabric-peer-ext/mod/peer/storage/api"
)

type IDStore struct {
	SetUnderConstructionFlagStub        func(string) error
	setUnderConstructionFlagMutex       sync.RWMutex
	setUnderConstructionFlagArgsForCall []struct {
		arg1 string
	}
	setUnderConstructionFlagReturns struct {
		result1 error
	}
	setUnderConstructionFlagReturnsOnCall map[int]struct {
		result1 error
	}
	UnsetUnderConstructionFlagStub        func() error
	unsetUnderConstructionFlagMutex       sync.RWMutex
	unsetUnderConstructionFlagArgsForCall []struct{}
	unsetUnderConstructionFlagReturns     struct {
		result1 error
	}
	unsetUnderConstructionFlagReturnsOnCall map[int]struct {
		result1 error
	}
	GetUnderConstructionFlagStub        func() (string, error)
	getUnderConstructionFlagMutex       sync.RWMutex
	getUnderConstructionFlagArgsForCall []struct{}
	getUnderConstructionFlagReturns     struct {
		result1 string
		result2 error
	}
	getUnderConstructionFlagReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CreateLedgerIDStub        func(ledgerID string, gb *common.Block) error
	createLedgerIDMutex       sync.RWMutex
	createLedgerIDArgsForCall []struct {
		ledgerID string
		gb       *common.Block
	}
	createLedgerIDReturns struct {
		result1 error
	}
	createLedgerIDReturnsOnCall map[int]struct {
		result1 error
	}
	LedgerIDExistsStub        func(ledgerID string) (bool, error)
	ledgerIDExistsMutex       sync.RWMutex
	ledgerIDExistsArgsForCall []struct {
		ledgerID string
	}
	ledgerIDExistsReturns struct {
		result1 bool
		result2 error
	}
	ledgerIDExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	LedgerIDActiveStub        func(ledgerID string) (active bool, exists bool, err error)
	ledgerIDActiveMutex       sync.RWMutex
	ledgerIDActiveArgsForCall []struct {
		ledgerID string
	}
	ledgerIDActiveReturns struct {
		result1 bool
		result2 bool
		result3 error
	}
	ledgerIDActiveReturnsOnCall map[int]struct {
		result1 bool
		result2 bool
		result3 error
	}
	GetActiveLedgerIDsStub        func() ([]string, error)
	getActiveLedgerIDsMutex       sync.RWMutex
	getActiveLedgerIDsArgsForCall []struct{}
	getActiveLedgerIDsReturns     struct {
		result1 []string
		result2 error
	}
	getActiveLedgerIDsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	UpdateLedgerStatusStub        func(ledgerID string, newStatus msgs.Status) error
	updateLedgerStatusMutex       sync.RWMutex
	updateLedgerStatusArgsForCall []struct {
		ledgerID  string
		newStatus msgs.Status
	}
	updateLedgerStatusReturns struct {
		result1 error
	}
	updateLedgerStatusReturnsOnCall map[int]struct {
		result1 error
	}
	GetFormatStub        func() ([]byte, error)
	getFormatMutex       sync.RWMutex
	getFormatArgsForCall []struct{}
	getFormatReturns     struct {
		result1 []byte
		result2 error
	}
	getFormatReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	UpgradeFormatStub        func() error
	upgradeFormatMutex       sync.RWMutex
	upgradeFormatArgsForCall []struct{}
	upgradeFormatReturns     struct {
		result1 error
	}
	upgradeFormatReturnsOnCall map[int]struct {
		result1 error
	}
	GetGenesisBlockStub        func(ledgerID string) (*common.Block, error)
	getGenesisBlockMutex       sync.RWMutex
	getGenesisBlockArgsForCall []struct {
		ledgerID string
	}
	getGenesisBlockReturns struct {
		result1 *common.Block
		result2 error
	}
	getGenesisBlockReturnsOnCall map[int]struct {
		result1 *common.Block
		result2 error
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct{}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *IDStore) SetUnderConstructionFlag(arg1 string) error {
	fake.setUnderConstructionFlagMutex.Lock()
	ret, specificReturn := fake.setUnderConstructionFlagReturnsOnCall[len(fake.setUnderConstructionFlagArgsForCall)]
	fake.setUnderConstructionFlagArgsForCall = append(fake.setUnderConstructionFlagArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetUnderConstructionFlag", []interface{}{arg1})
	fake.setUnderConstructionFlagMutex.Unlock()
	if fake.SetUnderConstructionFlagStub != nil {
		return fake.SetUnderConstructionFlagStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setUnderConstructionFlagReturns.result1
}

func (fake *IDStore) SetUnderConstructionFlagCallCount() int {
	fake.setUnderConstructionFlagMutex.RLock()
	defer fake.setUnderConstructionFlagMutex.RUnlock()
	return len(fake.setUnderConstructionFlagArgsForCall)
}

func (fake *IDStore) SetUnderConstructionFlagArgsForCall(i int) string {
	fake.setUnderConstructionFlagMutex.RLock()
	defer fake.setUnderConstructionFlagMutex.RUnlock()
	return fake.setUnderConstructionFlagArgsForCall[i].arg1
}

func (fake *IDStore) SetUnderConstructionFlagReturns(result1 error) {
	fake.SetUnderConstructionFlagStub = nil
	fake.setUnderConstructionFlagReturns = struct {
		result1 error
	}{result1}
}

func (fake *IDStore) SetUnderConstructionFlagReturnsOnCall(i int, result1 error) {
	fake.SetUnderConstructionFlagStub = nil
	if fake.setUnderConstructionFlagReturnsOnCall == nil {
		fake.setUnderConstructionFlagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setUnderConstructionFlagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IDStore) UnsetUnderConstructionFlag() error {
	fake.unsetUnderConstructionFlagMutex.Lock()
	ret, specificReturn := fake.unsetUnderConstructionFlagReturnsOnCall[len(fake.unsetUnderConstructionFlagArgsForCall)]
	fake.unsetUnderConstructionFlagArgsForCall = append(fake.unsetUnderConstructionFlagArgsForCall, struct{}{})
	fake.recordInvocation("UnsetUnderConstructionFlag", []interface{}{})
	fake.unsetUnderConstructionFlagMutex.Unlock()
	if fake.UnsetUnderConstructionFlagStub != nil {
		return fake.UnsetUnderConstructionFlagStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unsetUnderConstructionFlagReturns.result1
}

func (fake *IDStore) UnsetUnderConstructionFlagCallCount() int {
	fake.unsetUnderConstructionFlagMutex.RLock()
	defer fake.unsetUnderConstructionFlagMutex.RUnlock()
	return len(fake.unsetUnderConstructionFlagArgsForCall)
}

func (fake *IDStore) UnsetUnderConstructionFlagReturns(result1 error) {
	fake.UnsetUnderConstructionFlagStub = nil
	fake.unsetUnderConstructionFlagReturns = struct {
		result1 error
	}{result1}
}

func (fake *IDStore) UnsetUnderConstructionFlagReturnsOnCall(i int, result1 error) {
	fake.UnsetUnderConstructionFlagStub = nil
	if fake.unsetUnderConstructionFlagReturnsOnCall == nil {
		fake.unsetUnderConstructionFlagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unsetUnderConstructionFlagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IDStore) GetUnderConstructionFlag() (string, error) {
	fake.getUnderConstructionFlagMutex.Lock()
	ret, specificReturn := fake.getUnderConstructionFlagReturnsOnCall[len(fake.getUnderConstructionFlagArgsForCall)]
	fake.getUnderConstructionFlagArgsForCall = append(fake.getUnderConstructionFlagArgsForCall, struct{}{})
	fake.recordInvocation("GetUnderConstructionFlag", []interface{}{})
	fake.getUnderConstructionFlagMutex.Unlock()
	if fake.GetUnderConstructionFlagStub != nil {
		return fake.GetUnderConstructionFlagStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getUnderConstructionFlagReturns.result1, fake.getUnderConstructionFlagReturns.result2
}

func (fake *IDStore) GetUnderConstructionFlagCallCount() int {
	fake.getUnderConstructionFlagMutex.RLock()
	defer fake.getUnderConstructionFlagMutex.RUnlock()
	return len(fake.getUnderConstructionFlagArgsForCall)
}

func (fake *IDStore) GetUnderConstructionFlagReturns(result1 string, result2 error) {
	fake.GetUnderConstructionFlagStub = nil
	fake.getUnderConstructionFlagReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *IDStore) GetUnderConstructionFlagReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetUnderConstructionFlagStub = nil
	if fake.getUnderConstructionFlagReturnsOnCall == nil {
		fake.getUnderConstructionFlagReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getUnderConstructionFlagReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *IDStore) CreateLedgerID(ledgerID string, gb *common.Block) error {
	fake.createLedgerIDMutex.Lock()
	ret, specificReturn := fake.createLedgerIDReturnsOnCall[len(fake.createLedgerIDArgsForCall)]
	fake.createLedgerIDArgsForCall = append(fake.createLedgerIDArgsForCall, struct {
		ledgerID string
		gb       *common.Block
	}{ledgerID, gb})
	fake.recordInvocation("CreateLedgerID", []interface{}{ledgerID, gb})
	fake.createLedgerIDMutex.Unlock()
	if fake.CreateLedgerIDStub != nil {
		return fake.CreateLedgerIDStub(ledgerID, gb)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createLedgerIDReturns.result1
}

func (fake *IDStore) CreateLedgerIDCallCount() int {
	fake.createLedgerIDMutex.RLock()
	defer fake.createLedgerIDMutex.RUnlock()
	return len(fake.createLedgerIDArgsForCall)
}

func (fake *IDStore) CreateLedgerIDArgsForCall(i int) (string, *common.Block) {
	fake.createLedgerIDMutex.RLock()
	defer fake.createLedgerIDMutex.RUnlock()
	return fake.createLedgerIDArgsForCall[i].ledgerID, fake.createLedgerIDArgsForCall[i].gb
}

func (fake *IDStore) CreateLedgerIDReturns(result1 error) {
	fake.CreateLedgerIDStub = nil
	fake.createLedgerIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *IDStore) CreateLedgerIDReturnsOnCall(i int, result1 error) {
	fake.CreateLedgerIDStub = nil
	if fake.createLedgerIDReturnsOnCall == nil {
		fake.createLedgerIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createLedgerIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IDStore) LedgerIDExists(ledgerID string) (bool, error) {
	fake.ledgerIDExistsMutex.Lock()
	ret, specificReturn := fake.ledgerIDExistsReturnsOnCall[len(fake.ledgerIDExistsArgsForCall)]
	fake.ledgerIDExistsArgsForCall = append(fake.ledgerIDExistsArgsForCall, struct {
		ledgerID string
	}{ledgerID})
	fake.recordInvocation("LedgerIDExists", []interface{}{ledgerID})
	fake.ledgerIDExistsMutex.Unlock()
	if fake.LedgerIDExistsStub != nil {
		return fake.LedgerIDExistsStub(ledgerID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.ledgerIDExistsReturns.result1, fake.ledgerIDExistsReturns.result2
}

func (fake *IDStore) LedgerIDExistsCallCount() int {
	fake.ledgerIDExistsMutex.RLock()
	defer fake.ledgerIDExistsMutex.RUnlock()
	return len(fake.ledgerIDExistsArgsForCall)
}

func (fake *IDStore) LedgerIDExistsArgsForCall(i int) string {
	fake.ledgerIDExistsMutex.RLock()
	defer fake.ledgerIDExistsMutex.RUnlock()
	return fake.ledgerIDExistsArgsForCall[i].ledgerID
}

func (fake *IDStore) LedgerIDExistsReturns(result1 bool, result2 error) {
	fake.LedgerIDExistsStub = nil
	fake.ledgerIDExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *IDStore) LedgerIDExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.LedgerIDExistsStub = nil
	if fake.ledgerIDExistsReturnsOnCall == nil {
		fake.ledgerIDExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.ledgerIDExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *IDStore) LedgerIDActive(ledgerID string) (active bool, exists bool, err error) {
	fake.ledgerIDActiveMutex.Lock()
	ret, specificReturn := fake.ledgerIDActiveReturnsOnCall[len(fake.ledgerIDActiveArgsForCall)]
	fake.ledgerIDActiveArgsForCall = append(fake.ledgerIDActiveArgsForCall, struct {
		ledgerID string
	}{ledgerID})
	fake.recordInvocation("LedgerIDActive", []interface{}{ledgerID})
	fake.ledgerIDActiveMutex.Unlock()
	if fake.LedgerIDActiveStub != nil {
		return fake.LedgerIDActiveStub(ledgerID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.ledgerIDActiveReturns.result1, fake.ledgerIDActiveReturns.result2, fake.ledgerIDActiveReturns.result3
}

func (fake *IDStore) LedgerIDActiveCallCount() int {
	fake.ledgerIDActiveMutex.RLock()
	defer fake.ledgerIDActiveMutex.RUnlock()
	return len(fake.ledgerIDActiveArgsForCall)
}

func (fake *IDStore) LedgerIDActiveArgsForCall(i int) string {
	fake.ledgerIDActiveMutex.RLock()
	defer fake.ledgerIDActiveMutex.RUnlock()
	return fake.ledgerIDActiveArgsForCall[i].ledgerID
}

func (fake *IDStore) LedgerIDActiveReturns(result1 bool, result2 bool, result3 error) {
	fake.LedgerIDActiveStub = nil
	fake.ledgerIDActiveReturns = struct {
		result1 bool
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *IDStore) LedgerIDActiveReturnsOnCall(i int, result1 bool, result2 bool, result3 error) {
	fake.LedgerIDActiveStub = nil
	if fake.ledgerIDActiveReturnsOnCall == nil {
		fake.ledgerIDActiveReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 bool
			result3 error
		})
	}
	fake.ledgerIDActiveReturnsOnCall[i] = struct {
		result1 bool
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *IDStore) GetActiveLedgerIDs() ([]string, error) {
	fake.getActiveLedgerIDsMutex.Lock()
	ret, specificReturn := fake.getActiveLedgerIDsReturnsOnCall[len(fake.getActiveLedgerIDsArgsForCall)]
	fake.getActiveLedgerIDsArgsForCall = append(fake.getActiveLedgerIDsArgsForCall, struct{}{})
	fake.recordInvocation("GetActiveLedgerIDs", []interface{}{})
	fake.getActiveLedgerIDsMutex.Unlock()
	if fake.GetActiveLedgerIDsStub != nil {
		return fake.GetActiveLedgerIDsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getActiveLedgerIDsReturns.result1, fake.getActiveLedgerIDsReturns.result2
}

func (fake *IDStore) GetActiveLedgerIDsCallCount() int {
	fake.getActiveLedgerIDsMutex.RLock()
	defer fake.getActiveLedgerIDsMutex.RUnlock()
	return len(fake.getActiveLedgerIDsArgsForCall)
}

func (fake *IDStore) GetActiveLedgerIDsReturns(result1 []string, result2 error) {
	fake.GetActiveLedgerIDsStub = nil
	fake.getActiveLedgerIDsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *IDStore) GetActiveLedgerIDsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.GetActiveLedgerIDsStub = nil
	if fake.getActiveLedgerIDsReturnsOnCall == nil {
		fake.getActiveLedgerIDsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getActiveLedgerIDsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *IDStore) UpdateLedgerStatus(ledgerID string, newStatus msgs.Status) error {
	fake.updateLedgerStatusMutex.Lock()
	ret, specificReturn := fake.updateLedgerStatusReturnsOnCall[len(fake.updateLedgerStatusArgsForCall)]
	fake.updateLedgerStatusArgsForCall = append(fake.updateLedgerStatusArgsForCall, struct {
		ledgerID  string
		newStatus msgs.Status
	}{ledgerID, newStatus})
	fake.recordInvocation("UpdateLedgerStatus", []interface{}{ledgerID, newStatus})
	fake.updateLedgerStatusMutex.Unlock()
	if fake.UpdateLedgerStatusStub != nil {
		return fake.UpdateLedgerStatusStub(ledgerID, newStatus)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateLedgerStatusReturns.result1
}

func (fake *IDStore) UpdateLedgerStatusCallCount() int {
	fake.updateLedgerStatusMutex.RLock()
	defer fake.updateLedgerStatusMutex.RUnlock()
	return len(fake.updateLedgerStatusArgsForCall)
}

func (fake *IDStore) UpdateLedgerStatusArgsForCall(i int) (string, msgs.Status) {
	fake.updateLedgerStatusMutex.RLock()
	defer fake.updateLedgerStatusMutex.RUnlock()
	return fake.updateLedgerStatusArgsForCall[i].ledgerID, fake.updateLedgerStatusArgsForCall[i].newStatus
}

func (fake *IDStore) UpdateLedgerStatusReturns(result1 error) {
	fake.UpdateLedgerStatusStub = nil
	fake.updateLedgerStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *IDStore) UpdateLedgerStatusReturnsOnCall(i int, result1 error) {
	fake.UpdateLedgerStatusStub = nil
	if fake.updateLedgerStatusReturnsOnCall == nil {
		fake.updateLedgerStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateLedgerStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IDStore) GetFormat() ([]byte, error) {
	fake.getFormatMutex.Lock()
	ret, specificReturn := fake.getFormatReturnsOnCall[len(fake.getFormatArgsForCall)]
	fake.getFormatArgsForCall = append(fake.getFormatArgsForCall, struct{}{})
	fake.recordInvocation("GetFormat", []interface{}{})
	fake.getFormatMutex.Unlock()
	if fake.GetFormatStub != nil {
		return fake.GetFormatStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getFormatReturns.result1, fake.getFormatReturns.result2
}

func (fake *IDStore) GetFormatCallCount() int {
	fake.getFormatMutex.RLock()
	defer fake.getFormatMutex.RUnlock()
	return len(fake.getFormatArgsForCall)
}

func (fake *IDStore) GetFormatReturns(result1 []byte, result2 error) {
	fake.GetFormatStub = nil
	fake.getFormatReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *IDStore) GetFormatReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.GetFormatStub = nil
	if fake.getFormatReturnsOnCall == nil {
		fake.getFormatReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getFormatReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *IDStore) UpgradeFormat() error {
	fake.upgradeFormatMutex.Lock()
	ret, specificReturn := fake.upgradeFormatReturnsOnCall[len(fake.upgradeFormatArgsForCall)]
	fake.upgradeFormatArgsForCall = append(fake.upgradeFormatArgsForCall, struct{}{})
	fake.recordInvocation("UpgradeFormat", []interface{}{})
	fake.upgradeFormatMutex.Unlock()
	if fake.UpgradeFormatStub != nil {
		return fake.UpgradeFormatStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.upgradeFormatReturns.result1
}

func (fake *IDStore) UpgradeFormatCallCount() int {
	fake.upgradeFormatMutex.RLock()
	defer fake.upgradeFormatMutex.RUnlock()
	return len(fake.upgradeFormatArgsForCall)
}

func (fake *IDStore) UpgradeFormatReturns(result1 error) {
	fake.UpgradeFormatStub = nil
	fake.upgradeFormatReturns = struct {
		result1 error
	}{result1}
}

func (fake *IDStore) UpgradeFormatReturnsOnCall(i int, result1 error) {
	fake.UpgradeFormatStub = nil
	if fake.upgradeFormatReturnsOnCall == nil {
		fake.upgradeFormatReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeFormatReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IDStore) GetGenesisBlock(ledgerID string) (*common.Block, error) {
	fake.getGenesisBlockMutex.Lock()
	ret, specificReturn := fake.getGenesisBlockReturnsOnCall[len(fake.getGenesisBlockArgsForCall)]
	fake.getGenesisBlockArgsForCall = append(fake.getGenesisBlockArgsForCall, struct {
		ledgerID string
	}{ledgerID})
	fake.recordInvocation("GetGenesisBlock", []interface{}{ledgerID})
	fake.getGenesisBlockMutex.Unlock()
	if fake.GetGenesisBlockStub != nil {
		return fake.GetGenesisBlockStub(ledgerID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getGenesisBlockReturns.result1, fake.getGenesisBlockReturns.result2
}

func (fake *IDStore) GetGenesisBlockCallCount() int {
	fake.getGenesisBlockMutex.RLock()
	defer fake.getGenesisBlockMutex.RUnlock()
	return len(fake.getGenesisBlockArgsForCall)
}

func (fake *IDStore) GetGenesisBlockArgsForCall(i int) string {
	fake.getGenesisBlockMutex.RLock()
	defer fake.getGenesisBlockMutex.RUnlock()
	return fake.getGenesisBlockArgsForCall[i].ledgerID
}

func (fake *IDStore) GetGenesisBlockReturns(result1 *common.Block, result2 error) {
	fake.GetGenesisBlockStub = nil
	fake.getGenesisBlockReturns = struct {
		result1 *common.Block
		result2 error
	}{result1, result2}
}

func (fake *IDStore) GetGenesisBlockReturnsOnCall(i int, result1 *common.Block, result2 error) {
	fake.GetGenesisBlockStub = nil
	if fake.getGenesisBlockReturnsOnCall == nil {
		fake.getGenesisBlockReturnsOnCall = make(map[int]struct {
			result1 *common.Block
			result2 error
		})
	}
	fake.getGenesisBlockReturnsOnCall[i] = struct {
		result1 *common.Block
		result2 error
	}{result1, result2}
}

func (fake *IDStore) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct{}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		fake.CloseStub()
	}
}

func (fake *IDStore) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *IDStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.setUnderConstructionFlagMutex.RLock()
	defer fake.setUnderConstructionFlagMutex.RUnlock()
	fake.unsetUnderConstructionFlagMutex.RLock()
	defer fake.unsetUnderConstructionFlagMutex.RUnlock()
	fake.getUnderConstructionFlagMutex.RLock()
	defer fake.getUnderConstructionFlagMutex.RUnlock()
	fake.createLedgerIDMutex.RLock()
	defer fake.createLedgerIDMutex.RUnlock()
	fake.ledgerIDExistsMutex.RLock()
	defer fake.ledgerIDExistsMutex.RUnlock()
	fake.ledgerIDActiveMutex.RLock()
	defer fake.ledgerIDActiveMutex.RUnlock()
	fake.getActiveLedgerIDsMutex.RLock()
	defer fake.getActiveLedgerIDsMutex.RUnlock()
	fake.updateLedgerStatusMutex.RLock()
	defer fake.updateLedgerStatusMutex.RUnlock()
	fake.getFormatMutex.RLock()
	defer fake.getFormatMutex.RUnlock()
	fake.upgradeFormatMutex.RLock()
	defer fake.upgradeFormatMutex.RUnlock()
	fake.getGenesisBlockMutex.RLock()
	defer fake.getGenesisBlockMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *IDStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ storageapi.IDStore = new(IDStore)
