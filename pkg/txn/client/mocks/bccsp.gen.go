// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"hash"
	"sync"

	"github.com/hyperledger/fabric/bccsp"
)

type BCCSP struct {
	KeyGenStub        func(opts bccsp.KeyGenOpts) (k bccsp.Key, err error)
	keyGenMutex       sync.RWMutex
	keyGenArgsForCall []struct {
		opts bccsp.KeyGenOpts
	}
	keyGenReturns struct {
		result1 bccsp.Key
		result2 error
	}
	keyGenReturnsOnCall map[int]struct {
		result1 bccsp.Key
		result2 error
	}
	KeyDerivStub        func(k bccsp.Key, opts bccsp.KeyDerivOpts) (dk bccsp.Key, err error)
	keyDerivMutex       sync.RWMutex
	keyDerivArgsForCall []struct {
		k    bccsp.Key
		opts bccsp.KeyDerivOpts
	}
	keyDerivReturns struct {
		result1 bccsp.Key
		result2 error
	}
	keyDerivReturnsOnCall map[int]struct {
		result1 bccsp.Key
		result2 error
	}
	KeyImportStub        func(raw interface{}, opts bccsp.KeyImportOpts) (k bccsp.Key, err error)
	keyImportMutex       sync.RWMutex
	keyImportArgsForCall []struct {
		raw  interface{}
		opts bccsp.KeyImportOpts
	}
	keyImportReturns struct {
		result1 bccsp.Key
		result2 error
	}
	keyImportReturnsOnCall map[int]struct {
		result1 bccsp.Key
		result2 error
	}
	GetKeyStub        func(ski []byte) (k bccsp.Key, err error)
	getKeyMutex       sync.RWMutex
	getKeyArgsForCall []struct {
		ski []byte
	}
	getKeyReturns struct {
		result1 bccsp.Key
		result2 error
	}
	getKeyReturnsOnCall map[int]struct {
		result1 bccsp.Key
		result2 error
	}
	HashStub        func(msg []byte, opts bccsp.HashOpts) (hash []byte, err error)
	hashMutex       sync.RWMutex
	hashArgsForCall []struct {
		msg  []byte
		opts bccsp.HashOpts
	}
	hashReturns struct {
		result1 []byte
		result2 error
	}
	hashReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetHashStub        func(opts bccsp.HashOpts) (h hash.Hash, err error)
	getHashMutex       sync.RWMutex
	getHashArgsForCall []struct {
		opts bccsp.HashOpts
	}
	getHashReturns struct {
		result1 hash.Hash
		result2 error
	}
	getHashReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	SignStub        func(k bccsp.Key, digest []byte, opts bccsp.SignerOpts) (signature []byte, err error)
	signMutex       sync.RWMutex
	signArgsForCall []struct {
		k      bccsp.Key
		digest []byte
		opts   bccsp.SignerOpts
	}
	signReturns struct {
		result1 []byte
		result2 error
	}
	signReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	VerifyStub        func(k bccsp.Key, signature, digest []byte, opts bccsp.SignerOpts) (valid bool, err error)
	verifyMutex       sync.RWMutex
	verifyArgsForCall []struct {
		k         bccsp.Key
		signature []byte
		digest    []byte
		opts      bccsp.SignerOpts
	}
	verifyReturns struct {
		result1 bool
		result2 error
	}
	verifyReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EncryptStub        func(k bccsp.Key, plaintext []byte, opts bccsp.EncrypterOpts) (ciphertext []byte, err error)
	encryptMutex       sync.RWMutex
	encryptArgsForCall []struct {
		k         bccsp.Key
		plaintext []byte
		opts      bccsp.EncrypterOpts
	}
	encryptReturns struct {
		result1 []byte
		result2 error
	}
	encryptReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	DecryptStub        func(k bccsp.Key, ciphertext []byte, opts bccsp.DecrypterOpts) (plaintext []byte, err error)
	decryptMutex       sync.RWMutex
	decryptArgsForCall []struct {
		k          bccsp.Key
		ciphertext []byte
		opts       bccsp.DecrypterOpts
	}
	decryptReturns struct {
		result1 []byte
		result2 error
	}
	decryptReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *BCCSP) KeyGen(opts bccsp.KeyGenOpts) (k bccsp.Key, err error) {
	fake.keyGenMutex.Lock()
	ret, specificReturn := fake.keyGenReturnsOnCall[len(fake.keyGenArgsForCall)]
	fake.keyGenArgsForCall = append(fake.keyGenArgsForCall, struct {
		opts bccsp.KeyGenOpts
	}{opts})
	fake.recordInvocation("KeyGen", []interface{}{opts})
	fake.keyGenMutex.Unlock()
	if fake.KeyGenStub != nil {
		return fake.KeyGenStub(opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.keyGenReturns.result1, fake.keyGenReturns.result2
}

func (fake *BCCSP) KeyGenCallCount() int {
	fake.keyGenMutex.RLock()
	defer fake.keyGenMutex.RUnlock()
	return len(fake.keyGenArgsForCall)
}

func (fake *BCCSP) KeyGenArgsForCall(i int) bccsp.KeyGenOpts {
	fake.keyGenMutex.RLock()
	defer fake.keyGenMutex.RUnlock()
	return fake.keyGenArgsForCall[i].opts
}

func (fake *BCCSP) KeyGenReturns(result1 bccsp.Key, result2 error) {
	fake.KeyGenStub = nil
	fake.keyGenReturns = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) KeyGenReturnsOnCall(i int, result1 bccsp.Key, result2 error) {
	fake.KeyGenStub = nil
	if fake.keyGenReturnsOnCall == nil {
		fake.keyGenReturnsOnCall = make(map[int]struct {
			result1 bccsp.Key
			result2 error
		})
	}
	fake.keyGenReturnsOnCall[i] = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) KeyDeriv(k bccsp.Key, opts bccsp.KeyDerivOpts) (dk bccsp.Key, err error) {
	fake.keyDerivMutex.Lock()
	ret, specificReturn := fake.keyDerivReturnsOnCall[len(fake.keyDerivArgsForCall)]
	fake.keyDerivArgsForCall = append(fake.keyDerivArgsForCall, struct {
		k    bccsp.Key
		opts bccsp.KeyDerivOpts
	}{k, opts})
	fake.recordInvocation("KeyDeriv", []interface{}{k, opts})
	fake.keyDerivMutex.Unlock()
	if fake.KeyDerivStub != nil {
		return fake.KeyDerivStub(k, opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.keyDerivReturns.result1, fake.keyDerivReturns.result2
}

func (fake *BCCSP) KeyDerivCallCount() int {
	fake.keyDerivMutex.RLock()
	defer fake.keyDerivMutex.RUnlock()
	return len(fake.keyDerivArgsForCall)
}

func (fake *BCCSP) KeyDerivArgsForCall(i int) (bccsp.Key, bccsp.KeyDerivOpts) {
	fake.keyDerivMutex.RLock()
	defer fake.keyDerivMutex.RUnlock()
	return fake.keyDerivArgsForCall[i].k, fake.keyDerivArgsForCall[i].opts
}

func (fake *BCCSP) KeyDerivReturns(result1 bccsp.Key, result2 error) {
	fake.KeyDerivStub = nil
	fake.keyDerivReturns = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) KeyDerivReturnsOnCall(i int, result1 bccsp.Key, result2 error) {
	fake.KeyDerivStub = nil
	if fake.keyDerivReturnsOnCall == nil {
		fake.keyDerivReturnsOnCall = make(map[int]struct {
			result1 bccsp.Key
			result2 error
		})
	}
	fake.keyDerivReturnsOnCall[i] = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) KeyImport(raw interface{}, opts bccsp.KeyImportOpts) (k bccsp.Key, err error) {
	fake.keyImportMutex.Lock()
	ret, specificReturn := fake.keyImportReturnsOnCall[len(fake.keyImportArgsForCall)]
	fake.keyImportArgsForCall = append(fake.keyImportArgsForCall, struct {
		raw  interface{}
		opts bccsp.KeyImportOpts
	}{raw, opts})
	fake.recordInvocation("KeyImport", []interface{}{raw, opts})
	fake.keyImportMutex.Unlock()
	if fake.KeyImportStub != nil {
		return fake.KeyImportStub(raw, opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.keyImportReturns.result1, fake.keyImportReturns.result2
}

func (fake *BCCSP) KeyImportCallCount() int {
	fake.keyImportMutex.RLock()
	defer fake.keyImportMutex.RUnlock()
	return len(fake.keyImportArgsForCall)
}

func (fake *BCCSP) KeyImportArgsForCall(i int) (interface{}, bccsp.KeyImportOpts) {
	fake.keyImportMutex.RLock()
	defer fake.keyImportMutex.RUnlock()
	return fake.keyImportArgsForCall[i].raw, fake.keyImportArgsForCall[i].opts
}

func (fake *BCCSP) KeyImportReturns(result1 bccsp.Key, result2 error) {
	fake.KeyImportStub = nil
	fake.keyImportReturns = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) KeyImportReturnsOnCall(i int, result1 bccsp.Key, result2 error) {
	fake.KeyImportStub = nil
	if fake.keyImportReturnsOnCall == nil {
		fake.keyImportReturnsOnCall = make(map[int]struct {
			result1 bccsp.Key
			result2 error
		})
	}
	fake.keyImportReturnsOnCall[i] = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) GetKey(ski []byte) (k bccsp.Key, err error) {
	var skiCopy []byte
	if ski != nil {
		skiCopy = make([]byte, len(ski))
		copy(skiCopy, ski)
	}
	fake.getKeyMutex.Lock()
	ret, specificReturn := fake.getKeyReturnsOnCall[len(fake.getKeyArgsForCall)]
	fake.getKeyArgsForCall = append(fake.getKeyArgsForCall, struct {
		ski []byte
	}{skiCopy})
	fake.recordInvocation("GetKey", []interface{}{skiCopy})
	fake.getKeyMutex.Unlock()
	if fake.GetKeyStub != nil {
		return fake.GetKeyStub(ski)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getKeyReturns.result1, fake.getKeyReturns.result2
}

func (fake *BCCSP) GetKeyCallCount() int {
	fake.getKeyMutex.RLock()
	defer fake.getKeyMutex.RUnlock()
	return len(fake.getKeyArgsForCall)
}

func (fake *BCCSP) GetKeyArgsForCall(i int) []byte {
	fake.getKeyMutex.RLock()
	defer fake.getKeyMutex.RUnlock()
	return fake.getKeyArgsForCall[i].ski
}

func (fake *BCCSP) GetKeyReturns(result1 bccsp.Key, result2 error) {
	fake.GetKeyStub = nil
	fake.getKeyReturns = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) GetKeyReturnsOnCall(i int, result1 bccsp.Key, result2 error) {
	fake.GetKeyStub = nil
	if fake.getKeyReturnsOnCall == nil {
		fake.getKeyReturnsOnCall = make(map[int]struct {
			result1 bccsp.Key
			result2 error
		})
	}
	fake.getKeyReturnsOnCall[i] = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) Hash(msg []byte, opts bccsp.HashOpts) (hash []byte, err error) {
	var msgCopy []byte
	if msg != nil {
		msgCopy = make([]byte, len(msg))
		copy(msgCopy, msg)
	}
	fake.hashMutex.Lock()
	ret, specificReturn := fake.hashReturnsOnCall[len(fake.hashArgsForCall)]
	fake.hashArgsForCall = append(fake.hashArgsForCall, struct {
		msg  []byte
		opts bccsp.HashOpts
	}{msgCopy, opts})
	fake.recordInvocation("Hash", []interface{}{msgCopy, opts})
	fake.hashMutex.Unlock()
	if fake.HashStub != nil {
		return fake.HashStub(msg, opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hashReturns.result1, fake.hashReturns.result2
}

func (fake *BCCSP) HashCallCount() int {
	fake.hashMutex.RLock()
	defer fake.hashMutex.RUnlock()
	return len(fake.hashArgsForCall)
}

func (fake *BCCSP) HashArgsForCall(i int) ([]byte, bccsp.HashOpts) {
	fake.hashMutex.RLock()
	defer fake.hashMutex.RUnlock()
	return fake.hashArgsForCall[i].msg, fake.hashArgsForCall[i].opts
}

func (fake *BCCSP) HashReturns(result1 []byte, result2 error) {
	fake.HashStub = nil
	fake.hashReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) HashReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.HashStub = nil
	if fake.hashReturnsOnCall == nil {
		fake.hashReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.hashReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) GetHash(opts bccsp.HashOpts) (h hash.Hash, err error) {
	fake.getHashMutex.Lock()
	ret, specificReturn := fake.getHashReturnsOnCall[len(fake.getHashArgsForCall)]
	fake.getHashArgsForCall = append(fake.getHashArgsForCall, struct {
		opts bccsp.HashOpts
	}{opts})
	fake.recordInvocation("GetHash", []interface{}{opts})
	fake.getHashMutex.Unlock()
	if fake.GetHashStub != nil {
		return fake.GetHashStub(opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getHashReturns.result1, fake.getHashReturns.result2
}

func (fake *BCCSP) GetHashCallCount() int {
	fake.getHashMutex.RLock()
	defer fake.getHashMutex.RUnlock()
	return len(fake.getHashArgsForCall)
}

func (fake *BCCSP) GetHashArgsForCall(i int) bccsp.HashOpts {
	fake.getHashMutex.RLock()
	defer fake.getHashMutex.RUnlock()
	return fake.getHashArgsForCall[i].opts
}

func (fake *BCCSP) GetHashReturns(result1 hash.Hash, result2 error) {
	fake.GetHashStub = nil
	fake.getHashReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) GetHashReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.GetHashStub = nil
	if fake.getHashReturnsOnCall == nil {
		fake.getHashReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.getHashReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) Sign(k bccsp.Key, digest []byte, opts bccsp.SignerOpts) (signature []byte, err error) {
	var digestCopy []byte
	if digest != nil {
		digestCopy = make([]byte, len(digest))
		copy(digestCopy, digest)
	}
	fake.signMutex.Lock()
	ret, specificReturn := fake.signReturnsOnCall[len(fake.signArgsForCall)]
	fake.signArgsForCall = append(fake.signArgsForCall, struct {
		k      bccsp.Key
		digest []byte
		opts   bccsp.SignerOpts
	}{k, digestCopy, opts})
	fake.recordInvocation("Sign", []interface{}{k, digestCopy, opts})
	fake.signMutex.Unlock()
	if fake.SignStub != nil {
		return fake.SignStub(k, digest, opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.signReturns.result1, fake.signReturns.result2
}

func (fake *BCCSP) SignCallCount() int {
	fake.signMutex.RLock()
	defer fake.signMutex.RUnlock()
	return len(fake.signArgsForCall)
}

func (fake *BCCSP) SignArgsForCall(i int) (bccsp.Key, []byte, bccsp.SignerOpts) {
	fake.signMutex.RLock()
	defer fake.signMutex.RUnlock()
	return fake.signArgsForCall[i].k, fake.signArgsForCall[i].digest, fake.signArgsForCall[i].opts
}

func (fake *BCCSP) SignReturns(result1 []byte, result2 error) {
	fake.SignStub = nil
	fake.signReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) SignReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.SignStub = nil
	if fake.signReturnsOnCall == nil {
		fake.signReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.signReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) Verify(k bccsp.Key, signature []byte, digest []byte, opts bccsp.SignerOpts) (valid bool, err error) {
	var signatureCopy []byte
	if signature != nil {
		signatureCopy = make([]byte, len(signature))
		copy(signatureCopy, signature)
	}
	var digestCopy []byte
	if digest != nil {
		digestCopy = make([]byte, len(digest))
		copy(digestCopy, digest)
	}
	fake.verifyMutex.Lock()
	ret, specificReturn := fake.verifyReturnsOnCall[len(fake.verifyArgsForCall)]
	fake.verifyArgsForCall = append(fake.verifyArgsForCall, struct {
		k         bccsp.Key
		signature []byte
		digest    []byte
		opts      bccsp.SignerOpts
	}{k, signatureCopy, digestCopy, opts})
	fake.recordInvocation("Verify", []interface{}{k, signatureCopy, digestCopy, opts})
	fake.verifyMutex.Unlock()
	if fake.VerifyStub != nil {
		return fake.VerifyStub(k, signature, digest, opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.verifyReturns.result1, fake.verifyReturns.result2
}

func (fake *BCCSP) VerifyCallCount() int {
	fake.verifyMutex.RLock()
	defer fake.verifyMutex.RUnlock()
	return len(fake.verifyArgsForCall)
}

func (fake *BCCSP) VerifyArgsForCall(i int) (bccsp.Key, []byte, []byte, bccsp.SignerOpts) {
	fake.verifyMutex.RLock()
	defer fake.verifyMutex.RUnlock()
	return fake.verifyArgsForCall[i].k, fake.verifyArgsForCall[i].signature, fake.verifyArgsForCall[i].digest, fake.verifyArgsForCall[i].opts
}

func (fake *BCCSP) VerifyReturns(result1 bool, result2 error) {
	fake.VerifyStub = nil
	fake.verifyReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) VerifyReturnsOnCall(i int, result1 bool, result2 error) {
	fake.VerifyStub = nil
	if fake.verifyReturnsOnCall == nil {
		fake.verifyReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.verifyReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) Encrypt(k bccsp.Key, plaintext []byte, opts bccsp.EncrypterOpts) (ciphertext []byte, err error) {
	var plaintextCopy []byte
	if plaintext != nil {
		plaintextCopy = make([]byte, len(plaintext))
		copy(plaintextCopy, plaintext)
	}
	fake.encryptMutex.Lock()
	ret, specificReturn := fake.encryptReturnsOnCall[len(fake.encryptArgsForCall)]
	fake.encryptArgsForCall = append(fake.encryptArgsForCall, struct {
		k         bccsp.Key
		plaintext []byte
		opts      bccsp.EncrypterOpts
	}{k, plaintextCopy, opts})
	fake.recordInvocation("Encrypt", []interface{}{k, plaintextCopy, opts})
	fake.encryptMutex.Unlock()
	if fake.EncryptStub != nil {
		return fake.EncryptStub(k, plaintext, opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.encryptReturns.result1, fake.encryptReturns.result2
}

func (fake *BCCSP) EncryptCallCount() int {
	fake.encryptMutex.RLock()
	defer fake.encryptMutex.RUnlock()
	return len(fake.encryptArgsForCall)
}

func (fake *BCCSP) EncryptArgsForCall(i int) (bccsp.Key, []byte, bccsp.EncrypterOpts) {
	fake.encryptMutex.RLock()
	defer fake.encryptMutex.RUnlock()
	return fake.encryptArgsForCall[i].k, fake.encryptArgsForCall[i].plaintext, fake.encryptArgsForCall[i].opts
}

func (fake *BCCSP) EncryptReturns(result1 []byte, result2 error) {
	fake.EncryptStub = nil
	fake.encryptReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) EncryptReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.EncryptStub = nil
	if fake.encryptReturnsOnCall == nil {
		fake.encryptReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.encryptReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) Decrypt(k bccsp.Key, ciphertext []byte, opts bccsp.DecrypterOpts) (plaintext []byte, err error) {
	var ciphertextCopy []byte
	if ciphertext != nil {
		ciphertextCopy = make([]byte, len(ciphertext))
		copy(ciphertextCopy, ciphertext)
	}
	fake.decryptMutex.Lock()
	ret, specificReturn := fake.decryptReturnsOnCall[len(fake.decryptArgsForCall)]
	fake.decryptArgsForCall = append(fake.decryptArgsForCall, struct {
		k          bccsp.Key
		ciphertext []byte
		opts       bccsp.DecrypterOpts
	}{k, ciphertextCopy, opts})
	fake.recordInvocation("Decrypt", []interface{}{k, ciphertextCopy, opts})
	fake.decryptMutex.Unlock()
	if fake.DecryptStub != nil {
		return fake.DecryptStub(k, ciphertext, opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.decryptReturns.result1, fake.decryptReturns.result2
}

func (fake *BCCSP) DecryptCallCount() int {
	fake.decryptMutex.RLock()
	defer fake.decryptMutex.RUnlock()
	return len(fake.decryptArgsForCall)
}

func (fake *BCCSP) DecryptArgsForCall(i int) (bccsp.Key, []byte, bccsp.DecrypterOpts) {
	fake.decryptMutex.RLock()
	defer fake.decryptMutex.RUnlock()
	return fake.decryptArgsForCall[i].k, fake.decryptArgsForCall[i].ciphertext, fake.decryptArgsForCall[i].opts
}

func (fake *BCCSP) DecryptReturns(result1 []byte, result2 error) {
	fake.DecryptStub = nil
	fake.decryptReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) DecryptReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.DecryptStub = nil
	if fake.decryptReturnsOnCall == nil {
		fake.decryptReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.decryptReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.keyGenMutex.RLock()
	defer fake.keyGenMutex.RUnlock()
	fake.keyDerivMutex.RLock()
	defer fake.keyDerivMutex.RUnlock()
	fake.keyImportMutex.RLock()
	defer fake.keyImportMutex.RUnlock()
	fake.getKeyMutex.RLock()
	defer fake.getKeyMutex.RUnlock()
	fake.hashMutex.RLock()
	defer fake.hashMutex.RUnlock()
	fake.getHashMutex.RLock()
	defer fake.getHashMutex.RUnlock()
	fake.signMutex.RLock()
	defer fake.signMutex.RUnlock()
	fake.verifyMutex.RLock()
	defer fake.verifyMutex.RUnlock()
	fake.encryptMutex.RLock()
	defer fake.encryptMutex.RUnlock()
	fake.decryptMutex.RLock()
	defer fake.decryptMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *BCCSP) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ bccsp.BCCSP = new(BCCSP)
